所谓智能指针，和普通指针的用法是相似的，但智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。



#### shared_ptr

每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。`shared_ptr<T>`（其中 `T` 表示指针指向的具体数据类型）的定义位于`<memory>`头文件，并位于`std`命名空间中。和`unique_ptr`、`weak_ptr`不同之处在于，多个`shared_ptr`智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 `shared_ptr`指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的`shared_ptr`指针（只有引用计数为 0 时，堆内存才会被自动释放）。



#### unique_ptr

作为智能指针的一种，`unique_ptr`指针自然也具备“在适当时机自动释放堆内存空间”的能力。和`shared_ptr`指针最大的不同之处在于，`unique_ptr`指针指向的堆内存无法同其它`unique_ptr`共享，也就是说，每个`unique_ptr`指针都独自拥有对其所指堆内存空间的所有权。这也就意味着，每个`unique_ptr`指针指向的堆内存空间的引用计数，都只能为 1，一旦该`unique_ptr`指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。



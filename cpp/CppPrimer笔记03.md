#### 1 命名空间和using声明



#### 2 标准库类型string

##### 2.1 定义和初始化

string可以使用默认初始化、拷贝初始化、直接初始化等多种方法初始化：

```cpp
string s0;                   // 默认初始化，s0是空串
string s1 = s0;              // 拷贝初始化，s1是s0的副本
string s2(s0);               // 直接初始化，s3的值是s0的值；
string s3 = "value";         // 拷贝初始化，s3是字面值"value"的副本，除最后的空字符；
string s4("value");          // 直接初始化，效果等价于上面
string s5(10, 'c');          // 直接初始化，s5的内容是"cccccccccc"
string s6 = sring(10, 'c');  // 拷贝初始化，等价于string temp(10, 'c'); string s6 = temp
```

**直接初始化与拷贝初始化**

- 如果使用`=`初始化变量，则执行拷贝初始化，把等号右边的值拷贝到新建对象中；
- 不使用则执行直接初始化。

##### 2.2 string对象上的操作

下面列出了string的一些操作：

```cpp
os << s;         // 将s写到输出流os中，返回os
is >> s;         // 从is中读取字符串赋给s，忽略开头的空白（空格符、换行符、制表符），直到遇见下一处空白，返回is
getline(is, s);  // 从is种读取一行赋给s，返回is
s1 + s2;         // 
s1 += s2;
s1 == s2;
s1 != s2;
s1 <= s2;
s1 >= s2;
```

可以使用`while(cin >> s)`读取未知数量的输入。

使用`getline`能够读取一整：

- 参数为一个输入流和一个`string`对象；
- 函数从给定输入流读取内容，直到遇到换行符为止（换行符也被读入）；
- 然后将所读内容保存到`string`对象中（不存换行符）；
- 若输入的一开始就是换行符，则得到的是空`string`；
- 返回它的流参数。

```cpp
string line;
while(getline(cin, line)) cout << line << endl;
```

`string`类和其他大多数标准库类型都定义了几种配套的类型，体现了标准库机器无关的特性：

- `string`对象的`size()`方法返回的`string::size_type`类型的值，就是其中一种；
- 它是一种无符号类型的值，而且能存下任何`string`对象的大小；
- 所有用于存放`string`类`size`函数返回的值的变量，都应该定义为这种类型（可以使用`auto`或`decltype`推断）；
- `size`方法返回的是无符号整数，不能在表达式中混用带符号和无符号的数，比如`n`是一个负值，则`s.size()<n`肯定为`true`。



#### 3 标准库类型vector

##### 3.1 定义和初始化vector

初始化的几种特殊情况：

- 使用拷贝初始化（使用`=`）时，只能提供一个初始值；
- 如果提供的是一个类内初始值，则只能使用拷贝初始化或花括号形式的初始化；
- 如果提供的是初始元素值的列表，只能把初始值都放在花括号内进行列表初始化。



#### 4 迭代器

##### 4.1 使用迭代器

拥有迭代器类型的标准库使用`iterator`和`const_iterator`来表示迭代器类型。



#### 5 数组

##### 5.1 定义和初始化数组

数组是一种复合类型，维度也是数组类型的一部分，其维度必须是一个常量表达式：

```cpp
unsigned cnt = 42;           // 非常量表达式
constexpr unsigned sz = 42;  // 常量表达式
int arr[10];                 // 正确
int *parr[sz];               // 正确
int bad[cnt];                // 错误，cnt不是常量表达式
string strs[get_size()];     // get_size是constexpr时正确
```

**由内向外理解复杂数组的声明**

理解数组声明含义的最好方法是从数组名字开始，由内向外顺序阅读，如：

```cpp
int *(&array)[10] = ptrs;
```

1. 变量名称与引用在一起，所以这是一个引用；
2. 这是一个绑定了10个元素的数组的引用；
3. 这是一个绑定了10个元素为指针的数组的引用；
4. 这是一个绑定了10个元素为int指针的数组的引用；

##### 5.2 访问数组元素

##### 5.3 指针和数组

在很多用到数组名字的地方，编译器会自动将其替换为指向数组首元素的指针：

- 比如当使用数组作为`auto`变量的初始值时，推断所得到的类型时指针而非数组
- 但使用`decltype`时上述转换则不会发生。

指针也是迭代器，可以使用`begin()`函数获取一个数组首元素的指针，通过`end()`获取数组的尾后元素的指针。

两个指针相减的结果是它们之间的距离，其类型为定义在`cstddef`中的`ptrdiff_t`；

**内置的下标运算符可以处理负值**。



#### 6 多维数组

要使用范围`for`循环语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型，这是为了避免数组被自动转成指针：

```cpp
for (auto row: ia)
  for (auto col: row)
    cout << col << endl;
```

这个程序无法通过编译：因为`row`不是引用类型，所以编译器初始化`row`为指针，因此`row`实际是`int*`，而内层循环就不合法了。

由多位数组名转换得来的指针实际是指向第一个内层数组的指针：

```cpp
int ia[3][4];
int (*ip)[4] = ia;  // p指向含有4个整数的数组
int *ipp[4];        // 整型指针的数组
```

通过`auto`或`decltype`关键字，可以尽可能在数组前面加上指针类型：

```cpp
for (auto p = ia; p != ia + 3; ++p)    // p的类型为int (*p)[4]
  for (auto q = *p; q != *p + 4; ++q)  // 自动转换成p指向数组的首元素
    cout << *q << endl;
```

使用`begin()`和`end()`可以更简洁得实现：

```cpp
for (auto p = begin(ia); p != end(ia); ++p)
  for (auto q = begin(*p); q != end(*p); ++q)
    cout << *q << endl;
```

可以使用类型别名简化多维数组的指针：

```cpp
using int_array = int[4];
typedef int int_array[4];
```


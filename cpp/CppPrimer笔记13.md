拷贝控制操作：

- 拷贝构造函数：定义当用同类型的另一个对象初始化本对象时做什么；
- 拷贝赋值函数：定义将一个对象赋予同类型的另一个对象时做什么；
- 移动构造函数：定义当用同类型的另一个对象初始化本对象时做什么；
- 移动赋值函数：定义将一个对象赋予同类型的另一个对象时做什么；
- 析构函数：当此类型对象被销毁时执行的操作。



#### 1 拷贝、赋值与销毁

##### 1.1 拷贝构造函数

##### 1.2 拷贝赋值运算符

##### 1.3 析构函数

##### 1.4 3/5法则

##### 1.5 使用=default

##### 1.6 阻止拷贝

**定义删除函数**：可以将拷贝函数和拷贝赋值运算符的参数列表后面加上`=delete`，将函数定义为删除函数来阻止拷贝：

- 删除函数表示，虽然声明了它们，但不能以任何方式使用它们；
- 与`=default`不同，`=delete`必须出现在函数第一次声明的时候；
- 与`=default`不同，可以对任何函数指定`=delete`；

**析构函数不能是删除的成员**：若删除了一个类型的析构函数，或某个成员的类型删除了析构函数，就无法销毁此类型对象，因此编译器：

- 不允许定义该类型的变量或创建该类型的临时变量；
- 可以动态分配这种类型的对象，但不能释放这些对象。

**合成的拷贝控制成员可能是删除的**：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的，

|               类某个成员的XX删除的/不可访问的                | 合成的析构函数 | 合成的拷贝构造函数 | 合成的拷贝赋值运算符 | 合成的默认构造函数 |
| :----------------------------------------------------------: | :------------: | :----------------: | :------------------: | :----------------: |
|                          析构函数是                          |     删除的     |       删除的       |                      |       删除的       |
|                         拷贝构造函数                         |                |       删除的       |                      |                    |
|                        拷贝赋值运算符                        |                |                    |        删除的        |                    |
|                       类有一个引用成员                       |                |                    |        删除的        |                    |
|        类有一个引用成员且：<br />1. 没有类内初始化器         |                |                    |        删除的        |       删除的       |
|                      类有一个const成员                       |                |                    |        删除的        |                    |
| 类有一个const成员其：<br />1. 无类内初始化器<br />2. 类型未显式定义默认构造函数 |                |                    |        删除的        |       删除的       |

**private拷贝控制**：声明但不定义一个成员函数是合法的（后面有一个例外），试图访问一个未定义的成员将会导致一个链接时错误。通过**声明（但不定义）**`private`的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图（拷贝赋值运算符类似）：

- 试图拷贝对象的用户代码将在编译阶段被标记为错误；
- 成员函数或友元函数中的拷贝操作将会导致链接时错误。

希望阻止拷贝的类应该使用`=delete`来定义其拷贝构造函数和拷贝赋值运算符，而不应该将其声明为`private`。



#### 2 拷贝控制和资源管理

管理类外资源的类需要通过析构函数来释放对象所分配的资源，必须定义拷贝控制成员。在定义之前必须明确此类型对象的拷贝语义，一般有两种选择：

- 类的行为像一个值，也有自己的状态，拷贝一个这样的对象时，副本和原对象完全独立，比如标准库容器和string类；
- 类的行为像一个指针，副本和原对象共享状态，使用相同的底层数据结构，改变副本会改变原对象，比如shared_ptr；

而IO类型和unique_ptr不允许拷贝或赋值，因此行为既不像值也不像指针。

##### 2.1 行为像值的类

对于行为类值的类，其管理的资源，每个对象应该都有一份自己的拷贝。

**类值拷贝赋值运算符**

赋值运算符通常组合了析构函数和构造函数的操作：

- 类似析构函数，赋值操作会销毁左侧运算对象的资源；
- 类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。

重要的是这些操作以正确的顺序执行：

- 即使将一个对象赋予它自身，也保证正确；
- 对异常是安全的，即当异常发生时，能将左侧的运算对象置于一个有意义的状态。

一个好的模式是：

- 先将右侧运算对象拷贝到一个局部临时变量中，这样销毁左侧现有成员就安全了；
- 销毁左侧运算对象的资源，将数据从临时对象拷贝到左侧运算对象的成员中。

```cpp
HasPtrv& HasPtrv::operator=(const HasPtrv& rhs)
{
    auto newp = new string(*rhs.ps);  // 拷贝底层string
    delete ps;                        // 释放旧内存
    ps = newp;                        // 从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this;                     // 返回本对象
}
```

##### 2.2 定义行为像指针的类

**引用计数**：其工作方式如下：

- 每个构造函数（拷贝构造函数除外）除初始化对象外，还要创建一个引用计数，用来记录有多少个对象正在与创建的对象共享状态；
- 创建一个对象时，只有一个对象共享状态，计数器初始化为1；
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，并递增共享的计数器；
- 析构函数递减计数器，若计数器变为0，则析构函数释放状态；
- 拷贝赋值运算符递增右侧对象的计数器，递减左侧对象的计数器，若左侧对象计数器减为0，则拷贝赋值运算符必须销毁状态。

可以将计数器保存在动态内存中：

- 创建一个对象时也分配一个新计数器；
- 拷贝或赋值对象时，拷贝指向计数器的指针。

**定义一个使用引用计数器的类**

```cpp
class HasPtrp
{
public:
    HasPtrp(const string& s = new string()): ps(new string(s)), i(0), use(new size_t(1)) { }
    HasPtrp(const HasPtrp& p): ps(p.ps), i(ps.i), use(ps.use) { ++*use; }
    HasPtrp& operator=(const HasPtrp&);
    ~HasPtrp();

private:
    string* ps;
    int i;
    size_t *use;
};
```

**类指针的拷贝成员“篡改”引用计数**

```cpp
HasPtrp::~HasPtrp()
{
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
}

// 赋值运算符必须处理自赋值
HasPtrp& HasPtrp::operator=(const HasPtrp& rhs)
{
    ++*rhs.use;        // 递增右侧运算对象的引用计数，解决自赋值的问题；
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```



#### 3 交换操作

与重排元素顺序算法一起使用的类，定义`swap`非常重要：

- 这类算法在需要交换两个元素时会调用`swap`；
- 若类定义了自己的`swap`，算法调用自定义版本，否则调用标准库版本；
- 标准库实现的`swap`，交换两个对象需要一次拷贝和两次赋值；
- 其中涉及到的一些内存分配是不必要的，`swap`指针的效率更高。

**编写自己的`swap`函数**

```cpp
class HasPtrv
{
    friend void swap(HasPtrv&, HasPtrv&);
    // other code
};


inline void swap(HasPtrv& lhs, HasPtrv& rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

对于分配了资源的类，定义`swap`可能是一种很重要的优化手段。

**调用`swap`而非`std::swap`**

```cpp
void swap(Foo& lhs, FOO& rhs)
{
    using std::swap;
    swap(lhs.h, rhs.h);  // 使用HasPtrv版本的swap
  // 交换Foo其他函数成员
}
```

上例中，如果存在类型特定的swap版本，匹配程度会优于std中定义的版本。

**在赋值运算符中使用`swap`**

定义`swap`的类通常通过拷贝并交换技术，使用它来定义类的赋值运算符，将左侧运算对象与右侧运算对象的一个副本进行交换：

```cpp
HasPtrv& HasPtrv::operator=(HasPtrv rhs)  // 注意rhs是按值传递的
{
    swap(*this, rhs);  // rhs现在指向本对象曾经使用的内存
    return *this;      // rhs被销毁，delete了rhs中的指针
}
```

这个技术优点在于：

- 自动处理了自赋值的情况；
- 天然就是异常安全的。



#### 4 拷贝控制示例



#### 5 动态内存管理



#### 6 对象移动

使用对象移动的原因：

- 移动而非可以大幅度提升性能；
- 一些类不能拷贝但能移动（IO类或unique_ptr）。

可以用容器保存不可拷贝的对象，只要它们能被移动即可。

##### 6.1 右值引用

右值引用是必须被绑定到右值的引用：

- 通过`&&`而非`&`来获得右值引用；
- **右值引用只能绑定到一个将要销毁的对象**；
- 可以自由地将右值引用的资源移动到另一个对象中。

左值和右值是表达式的属性：

- 一个左值表达式表示的是一个对象的身份；
- 一个右值表达式表示的是对象的值。

一个右值引用也就是某个对象的另一个名字，但不同于左值引用：

- 它可以绑定到要求转换的表达式、字面常量或返回右值的表达式；
- 但不能将一个右值引用绑定到一个左值上。

一般而言：

- 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值，可以将一个左值引用绑定到这类表达式的结果上；
- 返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值，可以将一个const的左值引用或右值引用绑定到这类表达式。

**左值持久，右值短暂**


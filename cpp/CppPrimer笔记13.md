拷贝控制操作：

- 拷贝构造函数：定义当用同类型的另一个对象初始化本对象时做什么；
- 拷贝赋值函数：定义将一个对象赋予同类型的另一个对象时做什么；
- 移动构造函数：定义当用同类型的另一个对象初始化本对象时做什么；
- 移动赋值函数：定义将一个对象赋予同类型的另一个对象时做什么；
- 析构函数：当此类型对象被销毁时执行的操作。



#### 1 拷贝、赋值与销毁

##### 1.1 拷贝构造函数

拷贝构造函数的第一个参数必须是引用类型。

拷贝构造函数通常不应该是`explicit`的。

**合成拷贝构造函数**

即使定义了其他构造函数，编译器也会合成一个拷贝构造函数；

从给定对象中依次将每个非`static`成员拷贝到正在创建的对象中；

对于数组成员，合成拷贝函数也会逐元素地拷贝一个数组类型的成员。

**拷贝初始化**

拷贝初始化会在下面一些情况下发生：

- 使用`=`定义变量时；
- 将一个对象作为实参传递给一个非引用类型的形参；
- 从一个返回类型位非引用类型的函数返回一个对象；
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员；
- 某些类类型会对它们所分配的对象使用拷贝初始化，如初始化标准库容器或调用其`insert`或`push`成员。

##### 1.2 拷贝赋值运算符

##### 1.3 析构函数

##### 1.4 3/5法则

##### 1.5 使用=default

##### 1.6 阻止拷贝

**定义删除函数**：可以将拷贝函数和拷贝赋值运算符的参数列表后面加上`=delete`，将函数定义为删除函数来阻止拷贝：

- 删除函数表示，虽然声明了它们，但不能以任何方式使用它们；
- 与`=default`不同，`=delete`必须出现在函数第一次声明的时候；
- 与`=default`不同，可以对任何函数指定`=delete`；

**析构函数不能是删除的成员**：若删除了一个类型的析构函数，或某个成员的类型删除了析构函数，就无法销毁此类型对象，因此编译器：

- 不允许定义该类型的变量或创建该类型的临时变量；
- 可以动态分配这种类型的对象，但不能释放这些对象。

**合成的拷贝控制成员可能是删除的**：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的，

|               类某个成员的XX删除的/不可访问的                | 合成的析构函数 | 合成的拷贝构造函数 | 合成的拷贝赋值运算符 | 合成的默认构造函数 |
| :----------------------------------------------------------: | :------------: | :----------------: | :------------------: | :----------------: |
|                          析构函数是                          |     删除的     |       删除的       |                      |       删除的       |
|                         拷贝构造函数                         |                |       删除的       |                      |                    |
|                        拷贝赋值运算符                        |                |                    |        删除的        |                    |
|                       类有一个引用成员                       |                |                    |        删除的        |                    |
|        类有一个引用成员且：<br />1. 没有类内初始化器         |                |                    |        删除的        |       删除的       |
|                      类有一个const成员                       |                |                    |        删除的        |                    |
| 类有一个const成员其：<br />1. 无类内初始化器<br />2. 类型未显式定义默认构造函数 |                |                    |        删除的        |       删除的       |

**private拷贝控制**：声明但不定义一个成员函数是合法的（后面有一个例外），试图访问一个未定义的成员将会导致一个链接时错误。通过**声明（但不定义）**`private`的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图（拷贝赋值运算符类似）：

- 试图拷贝对象的用户代码将在编译阶段被标记为错误；
- 成员函数或友元函数中的拷贝操作将会导致链接时错误。

希望阻止拷贝的类应该使用`=delete`来定义其拷贝构造函数和拷贝赋值运算符，而不应该将其声明为`private`。



#### 2 拷贝控制和资源管理

管理类外资源的类需要通过析构函数来释放对象所分配的资源，必须定义拷贝控制成员。在定义之前必须明确此类型对象的拷贝语义，一般有两种选择：

- 类的行为像一个值，也有自己的状态，拷贝一个这样的对象时，副本和原对象完全独立，比如标准库容器和string类；
- 类的行为像一个指针，副本和原对象共享状态，使用相同的底层数据结构，改变副本会改变原对象，比如shared_ptr；

而IO类型和unique_ptr不允许拷贝或赋值，因此行为既不像值也不像指针。

##### 2.1 行为像值的类

对于行为类值的类，其管理的资源，每个对象应该都有一份自己的拷贝。

**类值拷贝赋值运算符**

赋值运算符通常组合了析构函数和构造函数的操作：

- 类似析构函数，赋值操作会销毁左侧运算对象的资源；
- 类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。

重要的是这些操作以正确的顺序执行：

- 即使将一个对象赋予它自身，也保证正确；
- 对异常是安全的，即当异常发生时，能将左侧的运算对象置于一个有意义的状态。

一个好的模式是：

- 先将右侧运算对象拷贝到一个局部临时变量中，这样销毁左侧现有成员就安全了；
- 销毁左侧运算对象的资源，将数据从临时对象拷贝到左侧运算对象的成员中。

```cpp
HasPtrv& HasPtrv::operator=(const HasPtrv& rhs)
{
    auto newp = new string(*rhs.ps);  // 拷贝底层string
    delete ps;                        // 释放旧内存
    ps = newp;                        // 从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this;                     // 返回本对象
}
```

##### 2.2 定义行为像指针的类

**引用计数**：其工作方式如下：

- 每个构造函数（拷贝构造函数除外）除初始化对象外，还要创建一个引用计数，用来记录有多少个对象正在与创建的对象共享状态；
- 创建一个对象时，只有一个对象共享状态，计数器初始化为1；
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，并递增共享的计数器；
- 析构函数递减计数器，若计数器变为0，则析构函数释放状态；
- 拷贝赋值运算符递增右侧对象的计数器，递减左侧对象的计数器，若左侧对象计数器减为0，则拷贝赋值运算符必须销毁状态。

可以将计数器保存在动态内存中：

- 创建一个对象时也分配一个新计数器；
- 拷贝或赋值对象时，拷贝指向计数器的指针。

**定义一个使用引用计数器的类**

```cpp
class HasPtrp
{
public:
    HasPtrp(const string& s = new string()): ps(new string(s)), i(0), use(new size_t(1)) { }
    HasPtrp(const HasPtrp& p): ps(p.ps), i(ps.i), use(ps.use) { ++*use; }
    HasPtrp& operator=(const HasPtrp&);
    ~HasPtrp();

private:
    string* ps;
    int i;
    size_t *use;
};
```

**类指针的拷贝成员“篡改”引用计数**

```cpp
HasPtrp::~HasPtrp()
{
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
}

// 赋值运算符必须处理自赋值
HasPtrp& HasPtrp::operator=(const HasPtrp& rhs)
{
    ++*rhs.use;        // 递增右侧运算对象的引用计数，解决自赋值的问题；
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```



#### 3 交换操作

与重排元素顺序算法一起使用的类，定义`swap`非常重要：

- 这类算法在需要交换两个元素时会调用`swap`；
- 若类定义了自己的`swap`，算法调用自定义版本，否则调用标准库版本；
- 标准库实现的`swap`，交换两个对象需要一次拷贝和两次赋值；
- 其中涉及到的一些内存分配是不必要的，`swap`指针的效率更高。

**编写自己的`swap`函数**

```cpp
class HasPtrv
{
    friend void swap(HasPtrv&, HasPtrv&);
    // other code
};


inline void swap(HasPtrv& lhs, HasPtrv& rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

对于分配了资源的类，定义`swap`可能是一种很重要的优化手段。

**调用`swap`而非`std::swap`**

```cpp
void swap(Foo& lhs, FOO& rhs)
{
    using std::swap;
    swap(lhs.h, rhs.h);  // 使用HasPtrv版本的swap
  // 交换Foo其他函数成员
}
```

上例中，如果存在类型特定的swap版本，匹配程度会优于std中定义的版本。

**在赋值运算符中使用`swap`**

定义`swap`的类通常通过拷贝并交换技术，使用它来定义类的赋值运算符，将左侧运算对象与右侧运算对象的一个副本进行交换：

```cpp
HasPtrv& HasPtrv::operator=(HasPtrv rhs)  // 注意rhs是按值传递的
{
    swap(*this, rhs);  // rhs现在指向本对象曾经使用的内存
    return *this;      // rhs被销毁，delete了rhs中的指针
}
```

这个技术优点在于：

- 自动处理了自赋值的情况；
- 天然就是异常安全的。



#### 4 拷贝控制示例



#### 5 动态内存管理



#### 6 对象移动

使用对象移动的原因：

- 移动而非可以大幅度提升性能；
- 一些类不能拷贝但能移动（IO类或unique_ptr）。

可以用容器保存不可拷贝的对象，只要它们能被移动即可。

##### 6.1 右值引用

右值引用是必须被绑定到右值的引用：

- 通过`&&`而非`&`来获得右值引用；
- **右值引用只能绑定到一个将要销毁的对象**；
- 可以自由地将右值引用的资源移动到另一个对象中。

左值和右值是表达式的属性：

- 一个左值表达式表示的是一个对象的身份；
- 一个右值表达式表示的是对象的值。

一个右值引用也就是某个对象的另一个名字，但不同于左值引用：

- 它可以绑定到要求转换的表达式、字面常量或返回右值的表达式；
- 但不能将一个右值引用绑定到一个左值上。

一般而言：

- 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值，可以将一个左值引用绑定到这类表达式的结果上；
- 返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值，可以将一个const的左值引用或右值引用绑定到这类表达式。

**左值持久，右值短暂**

左值和右值一个很明显的区别是：

- 左值有持久的状态；
- 右值要么是字面量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，则：

- 所引用的对象将被销毁；
- 该对象没有其他用户。

这两个特性意味着：使用右值引用的代码可以自由地接管所引用对象的资源。

注意：变量表达式都是左值，因此不能将一个右值引用绑定到一个右值引用类型的变量上：

```cpp
int &&rr1 = 42;
int &&rr2 = rr1;  // 错误，变量是左值，不能将右值引用绑定到变量上，即使这个变量是右值引用的类型
```

**标准库move函数**

可以显式地将一个左值转换为对应的右值引用类型，通过调用`move`函数（位于`utility`头文件）可以获得绑定到左值上的右值引用：

```cpp
int &&rr3 = move(rr1);
```

`move`告诉编译器，这是一个左值，但像一个右值一样处理它：

- 调用`move`意味着，除了对`rr1`赋值或销毁外，不再使用它；
- 调用`move`之后，不能对移后源对象的值做任何假设。

##### 6.2 移动构造函数和移动赋值运算符

让类支持移动操作，需定义移动构造函数和移动赋值运算符。移动构造函数：

- 第一个参数必须是该类类型的**右值引用**，任何额外的参数必须有默认实参；
- 完成移动后源对象必须不再指向被移动资源，这些资源所有权已归属新创建对象；
- 确保移后源对象处于可销毁状态，可以对它运行析构函数；
- 不分配任何新内存，不抛出任何异常。

```cpp
StrVec::StrVec(StrVec &&s) noexcept: elements(s.elements), firstfree(s.firstfree), capacity(s.capacity)
{
  s.elements = s.firstfree = s.capacity = nullptr;  // 令s进入可销毁状态
}
```

**移动操作、标准库容器和异常**

移动操作不分配任何资源，因此不会抛出任何异常，应该在构造函数中指明`noexcept`，将此事通知标准库，且在声明和定义中都需指定`noexcept`；否则标准库会认为移动类对象时可能抛出异常，为了处理这种可能会做一些额外的工作：

- 虽然移动操作通常不抛出异常，但抛出异常也是允许的；
- 标准库容器能对异常发生时自己的额行为提供保障。
- 除非标准库容器知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存过程中就必须使用拷贝构造函数而非移动构造函数（原因见474页）。
- 要使标准库在重新分配内存这类情况下对自定义类型的对象进行移动而非拷贝，就需显式地告诉它移动构造函数可以安全使用。

**移动赋值运算符**

移动赋值运算符也不抛出异常，且必须正确处理自赋值：

```cpp
StrVec& StrVec::operator=(StrVec&& rhs) noexcept
{
  if(this != &rhs)
  {
    free();
    elements = rhs.elements;
    firstfree = rhs.firstfree;
    capacity = rhs.capacity;
    rhs.elements = rhs.firstfree = rhs.capacity = nullptr;
  }
  return *this;
}
```

进行自赋值检测的原因是，此右值可能是`move`调用返回的结果，不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）。

**移后源对象必须可析构**

移动之后，源对象：

- 必须可析构
- 必须仍然是有效的，可以安全地为其赋予新值，或可以安全地使用而不依赖当前值；
- 留下的值没有任何要求，程序不应该依赖移后源对象中的数据。

**合成移动操作**

只有满足下面的条件，编译器才会位某个类合成移动操作：

- 没有定义任何自己版本的拷贝控制成员；
- 且所有数据成员都能能移动构造或移动赋值。

移动操作永远不会**隐式**定义为删除的函数；但若：

- 显式地要求编译器生成`=default`移动操作，
- 编译器不能移动所有成员，

则编译器会将移动操作定义为删除的函数。合成移动操作的原则：

- 有**类成员**：1定义了自己的拷贝构造函数且 2未定义移动构造函数                        ====>  类的移动构造函数被定义为删除的；
- 有**类成员**：1未定义自己的拷贝构造函数且 2编译器不能为其合成移动构造函数 ====> 类的移动构造函数被定义为删除的；
- 有**类成员**：移动构造函数或移动赋值运算符被定义为删除的或不可访问的          ====> 类的移动构造函数被定义为删除的；
- **类的**：析构函数被定义为删除的或不可访问的                                                        ====> 类的移动构造函数被定义为删除的；
- 有**类成员**：是`const`或是引用                                                                                   ====> 类的移动构造函数被定义为删除的；

如果类定义了一个移动构造函数和/或一个移动赋值运算符，则类的合成拷贝构造函数和拷贝赋值运算符被定义为删除的，因此定义了移动构造函数或移动赋值运算符的类也应该定义自己的拷贝操作。

**拷贝左值，移动右值**

若类既有移动操作，也有拷贝操作，则编译器使用函数匹配规则确定调用对象。在类中：

- 拷贝构造函数接受一个本类的`const`引用（如`const StrVec&`），因此可用于任何可转换为本类型的对象；
- 移动构造函数接受一个本类的右值引用（如`StrVec&&`），只能用于实参是（非`static`）的右值情形。

**如果没有移动构造函数，右值也被拷贝**

如果一个类没有移动构造函数，则该类的对象会被拷贝，即便调用`move`。值得注意的是，用拷贝操作代替移动操作几乎肯定是安全的。

**拷贝并交换赋值运算符和移动操作**

```cpp
class HasPtr
{
public:
  HasPtr(HasPtr&& p) noexcept: ps(p.ps), i(p.i) { p.ps=0; }
  HasPtr& operator=(HasPtr rhs) { swap(*this, rhs); return *this; } // 既是移动赋值运算符，也是拷贝赋值运算符
}

hp = hp2;        // 拷贝构造函数
hp = move(hp2);  // 移动构造函数
```

所有5个拷贝控制成员应该看成一个整体，定义了任何一个拷贝操作，就应该定义所有5个操作。
#### 静态函数库

这类库的名字一般是`libxxx.a`，利用静态函数库编译成的文件比较大，因为整个 函数库的所有数据都会被整合进目标代码中。其优点显而易见，编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。

##### 动态函数库

这类库的名字一般是`libxxx.so`，相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 linux系统有几个重要的目录存放相应的函数库，如`/lib /usr/lib`。

静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。

使用`-lmyhello`标记来告诉GCC驱动程序在连接阶段引用共享函数库`libmyhello.so`。`-L.`标记告诉GCC函数库可能位于当前目录。否则GNU连接器会查找标准系统函数目录，它先后搜索：

1. elf文件的`DT_RPATH`段；
2. 环境变量`LD_LIBRARY_PATH`；
3. `/etc/ld.so.cache`文件列表；
4. `./lib/`、`/usr/lib`目录找到库文件后将其载入内存。


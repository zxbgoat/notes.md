程序的使用的内存：

|       内存类型       |                  对象                  |         管理         |              生存期              |
| :------------------: | :------------------------------------: | :------------------: | :------------------------------: |
|       静态内存       | `static`成员、定义在所有函数之外的变量 | 编译器自动创建或销毁 | 在使用之前分配，在程序结束时销毁 |
|        栈内存        |      定义在函数内的非`static`对象      | 编译器自动创建或销毁 |   仅在其定义的程序块运行时存在   |
| 动态内存/自由空间/堆 |    动态分配、即程序运行时分配的对象    |      有程序控制      |      由程序定义其构建和销毁      |



#### 1 动态内存与智能指针

C++中通过一对运算符管理动态内存：

- `new`，在动态内存中为对象分配空间并返回一个指向该对象的指针，可选择对对象初始化；
- `delete`，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

为更容易和安全地使用动态内存，可以使用两种智能指针：

- `shared_ptr`：允许多个指针指向同一对象；
- `unique_ptr`：独占所指向的对象；
- `weak_ptr`：伴随类，一种弱引用，指向`shared_ptr`管理的对象。

##### 1.1 shared_ptr

智能指针也是模版，默认初始化的智能指针保存一个空指针。智能指针的使用方式与普通指针类似。下面是两个智能指针都支持的操作：

|                    操作                    |                             含义                             |
| :----------------------------------------: | :----------------------------------------------------------: |
| `shared_ptr<T> sp`<br />`unique_ptr<T> up` |               空智能指针，指向类型为`T`的对象                |
|                    `p`                     |                                                              |
|                    `*p`                    |                                                              |
|                  `p->mem`                  |                                                              |
|                 `p.get()`                  | 返回`p`中保存的指针，若智能指针释放了其对象，返回指针所指向的对象也会消失 |
|       `swap(p, q)`<br />`p.swap(q)`        |                                                              |

下面是`shared_ptr`独有的操作：

|        操作         |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
| `make_shared(args)` | 返回一个shared_ptr，指向用`args`初始化的动态分配的`T`类型的对象 |
| `shared_ptr<T>p(q)` |      `p`是shared_ptr `q`的拷贝，此操作会递增`q`的计数器      |
|       `p = q`       | 此操作会递减`p`原来指向对象的的引用计数，递增`q`指向对象的引用计数 |
|    `p.unique()`     |       若`p.use_count() = 1`，返回`true`，否则为`false`       |
|   `p.use_count()`   |    返回与`p`共享对象的智能指针的数量，速度较慢，用于调试     |

**make_shared函数**

**shared_ptr的拷贝与复制**

**shared_ptr自动销毁所管理的对象**

**shared_ptr释放相关联的内存**

**使用了动态生存期资源的类**



#### 2 动态数组

##### 2.1 new和数组

##### 2.2 allocator类

`new`将内存分配和对象构造组合在了一起，`delete`则将对象析构和内存释放组合在了一起，这可能会导致不必要的计算和空间的浪费。

若计划分配一大块内存，并在其上按需构造对象，需要将内存分配和对象构造分离。

**allocator类**

头文件`memory`中的`allocator`类，可以将内存分配和对象构造分离开来，它提供一种类型感知的内存分配方法，分配的内存时原始的、未构造的。`allocator`也是一个模版：

- 定义一个`allocator`对象时需指定分配对象的类型；
- 当一个`allocator`对象分配内存时根据，根据给定对象类型确定内存大小和对齐位置。

```cpp
allocator<string> alloc;           // 可分配string的allocator对象
auto const p = alloc.allocate(n);  // 分配n个未初始化的string
```

它支持的操作有：

|          算法          |                             操作                             |
| :--------------------: | :----------------------------------------------------------: |
|    `allocator<T> a`    |      定义名为`a`的allocator对象，可为类型T对象分配内存       |
|    `a.allocate(n)`     |       分配一段原始、未构造的内存，保存n个类型为T的对象       |
|  `a.deallocate(p, n)`  | 释放从`T*`指针`p`中地址开始的、保存了n个T类型对象的内存；<br />`p`须是先前`allocate`返回的指针，n须是创建时所要求的大小；<br />用户在`deallocate`前，必须对每个创建的对象调用`destroy` |
| `a.construct(p, args)` | `p`为`T*`指针，`args`为`T`构造函数的参数，在`p`指向的内存中构造一个`T`对象 |
|     `a.destroy(p)`     |          `p`为`T*`指针，对`p`指向的对象执行析构函数          |

**allocator分配未构造的内存**

- 为了使用`allocate`返回的内存，必须调用`construct`构造对象，使用未构造的内存行为是未定义的；
- 使用完对象后，必须对每个构造的元素调用`destroy`销毁，一旦销毁后又可以重新使用这部分内存；
- 可以使用`deallocate`来释放内存。

**拷贝和填充未初始化内存的算法**

标准库未`allocator`类定义了两个伴随算法，也定义在`memory`中：

|             算法              |                             操作                             |
| :---------------------------: | :----------------------------------------------------------: |
| `unintialized_copy(b, e, b2)` | 从迭代器`b`和`e`指定的范围拷贝元素到迭代器`b2`指定的原始内存；<br />`b2`指向的内存应足够大，能够容纳输入序列中的拷贝。 |
| `unintialized_copy(b, e, t)`  |   从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存   |
| `unintialized_fill(b, e, t)`  |   从迭代器`b`和`e`指定的原始范围创建值均为`t`的拷贝的对象    |
| `unintialized_fill(b, n, t)`  |  从迭代器`b`指向的内存地址开始创建`n`个值均为`t`拷贝的对象   |


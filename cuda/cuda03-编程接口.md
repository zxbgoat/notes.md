CUDA C++包含了：1）C++语言的最小扩展集；2）一个运行时库：

- 语言扩展的核心已在上一章介绍，它使开发者能：

  - 像C++函数一样定义核心，
  - 在每次调用时使用一些语法来指定网格和块的维度，

  任意包含这些扩展到源文件都必须使用nvcc编译；

- 运行时提供了**在主机上运行**的C和C++函数来：

  - 分配回收设备内存，
  - 在主机内存和设备内存之间迁移数据，
  - 多设备的管理系统
  - ...

  运行时构建在更低层的C API——CUDA驱动API之上。这种API：

  - 也能被调用，通过暴露一些更低层次的概念，提供了额外的控制层次；
  - 大多数应用并不需要使用这些控制层次。



#### 1 使用NVCC编译

##### 1.1 编译流程

###### 1.1.1 离线编译

用nvcc编译的源文件可以包含主机代码和设备代码，nvcc的基本流程包含将设备代码从主机代码分离出来，然后：

- 将设备代码编译成汇编形式（PTX代码）和/或二进制形式（cubin对象）；
- 通过将`<<<...>>>`语法替换成必要的CUDA运行时函数调用修改主机代码，从PTX代码和/或cubin对象中加载并运行每个编译的核心。

修改后的主机代码：

- 既可以输出为C++代码，留着被其他工具来进行编译；
- 也可以输出为对象代码，通过让nvcc在编译的最后阶段调用主机编译器实现。

之后应用：

- 即可以链接到编译后的主机代码（这是最普遍的情况）；
- 也可以忽略修改的主机代码，而使用CUDA驱动API来加载并执行PTX代码或cubin对象。

###### 1.1.2 即时编译


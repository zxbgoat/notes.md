##### 1 命令备忘

|                    命令                    |         功能          |        备注        |
| :--------------------------------------: | :-----------------: | :--------------: |
|                   `W`                    |    不计标点，光标移到下个单词    |    `B`、`E`类似     |
|                   `cc`                   |      改变当前整行内容       |      等价`S`       |
|                   `C`                    |      改变光标到行末内容      |      等价`c$`      |
|                   `D`                    |      删除光标到行末内容      |      等价`d$`      |
|                   `X`                    |       删除光标前字符       |                  |
|                   `P`                    |     将缓冲区内容置于光标前     |                  |
|                   `U`                    |       恢复一整行内容       |                  |
|                   `I`                    |        行首插入         |      `A`类似       |
|                   `J`                    |    合并两行，之间会有一个空格    |                  |
|                 `<C-F>`                  |      向前（下）滚动整屏      |    `<C-D>`半屏     |
|                 `<C-B>`                  |      向后（上）滚动整屏      |    `<C-U>`半屏     |
|                `z<enter>`                |     光标移到屏幕顶端并滚屏     |  `z.`中心、`z-`底端   |
|                 `<C-L>`                  |        重画屏幕         |                  |
|                   `H`                    |       移到屏幕顶端行       |   `M`中央、`L`底端    |
|                   `+`                    |      移到下行地一个字符      |      `-`上行       |
|                   `^`                    |     当前行第一个非空格处      |                  |
|                   `n|`                   |      移到当前行第n列       |      `nG`为行      |
|                   `(`                    |       移到当前句开头       |     `)`下句开头      |
|                   `{`                    |       移到当前段开头       |     `}`下段开头      |
|                   `[[`                   |       移到当前节开头       |     `]]`下节开头     |
|                   `n`                    |      重复搜索上一个模式      |      `N`反向       |
|                `/<enter>`                |      向前（下）重复搜索      | `?<enter>`向后（上）  |
|                   `fx`                   |   光标移到本行下一个出现x的地方   |     `Fx`上一个      |
|                   `tx`                   | 光标移到本行下一个出现x地方前一个字符 |     `Tx`上一个      |
|                   `;`                    |   重复上一个搜索命令，方向相同    |      `,`相反       |
|                 `<C-G>`                  |     显示位置、文件等信息      |                  |
| ``          |  两个反引号，回到上一个记号或上下文  |    `''`类似但到行首 |                     |                  |
|              `vim +n file`               |    在第n行打开file文件     | `vim + file`最后一行 |
|           `vim \pattern file`            | 在第一个符合pattern处打开文件  |                  |
|             `vim -r [file]`              |        恢复缓冲区        |                  |
|                   `mx`                   |      将当前位置标记成x      |                  |
|                   `'x`                   |     光标移到标记x所在行首     |     `x为回到x处      |
|                  `"3p`                   |    光标后放置缓冲区3内的文本    |     缓冲区可为1～9     |
|                  `"yyy`                  |     将当前行复制到缓冲区y     | 缓冲区可为a~z，命令也可`d` |
|                  `"Ddd`                  |    将当前行移动追加到缓冲区d    |    缓冲区用大写就是追加    |
|                  `"pp`                   |    将缓冲区p内容放置到光标后    |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |
|                                          |                     |                  |

vi会将最近9次的删除动作保存在9个编号的删除缓冲区中，比如要回复第三个，执行`"3p`。若不确定恢复哪一个，在恢复(`p`)一次后利用重复命令(`.`)做恢复，缓冲区编号就会自动增加，在利用`u`的恢复，即可实现下面的搜索：`"1pu.u.u.`。但仅对删除一整行有用。要恢复一行部分内容且`u`无效，使用`p`。

拖拽(`y`)与删除共享同一缓冲区。

通过数值前缀可以用`i`，`I`，`a`，`A`等插入命令插入一整行的字符。比如`50i*<esc>`会插入50个*。

vi会寻找?、.、!这些标点符号来辨认句子的结束。当这些标点符号后面至少有两个空格或作为一行的最后一个非空格字符时，vi将其定位为一个句子结束，若在句号后仅留了一个空格或句子以引号结尾时，vi无法辨认。“段落”的定义是下一个空白行前的文本，或是出现在troff MS macro package中默认的段落宏（.IP、.PP、.LP、.QP）前的任何文本；同理“小节”定义为下一个默认节宏（.NH、.SH、.H 1、.HU）前的文本。可通过`:set`命令自定义。

命令组合：`(number) (command) (text object)`，command为`c`、`d`或`y`，而text object为移动命令。

可将`y`与`d`搭配26个命名缓冲区(a~z)使用，方法为拖拽或删除命令前加上`"`以及缓冲区名称，如`"a7yy`、`"d5dd`等，使用`p`或`P`便可将内容取回：`"dp`、`"aP`。若使用大写字母制定缓冲区名称，则内容会被附加到当前缓冲区。因此就可以选择性地做移动与复制，如`"zd)`、`"Zy)`。

在vim会话中，可在某处做一个标记，然后在别处编辑，完成后回到书签位置。



##### 用ex中命令操作文本

vim是更通用、更底层的ex行编辑器的可视模式，有些ex命令在vim中十分有用，要在vim中使用ex命令，必须输入`:`，比如`:6`跳到第6行。ex命令包含了行地址以及命令，以`<enter>`结束，没有行号的命令被当作只对当前行起作用。指定行号的方法有：

- 指定明确行号：`:3,18d`为删除3~18行；`:160,224m23`将160行到224行移到23行之后；`:23,29t100`23到29行复制到100行后；`:=`列出总行数，`:.=`列出当前行号，`:/pattern/=`列出第一次出现pattern的行号；
- 用符号指定想对于当前位置行号：`.`表示当前行，`$`表示文件最后一行，`%`表示文件每一行，等价于`1,$`，因此`:.,$d`删除当前行到文件结尾的内容，`:%t$`将文件所有行复制到结尾；还可以用`+`和`-`类似算数操作一样指定相对当前行地址，`:-20,.m+20`将当前行前20行内容移动到当前行后20行之后，`:-,+#`显示当前行前一行到后一行的行号，`:--,++t0`将当前行前两行到后两行内容移到文件开头；`-`、`--`、`+`、`++`还可以这样依次类推；`0`与`-1`相同，都表示文件开头。
- 标识某些行的搜索模式作为地址：比如`:/patttern/+d`表示删除下一个包含pattern的下一行；`:/pattern1/,/pattern2/m$`表示将下一个pattern1到下一个pattern2的内容移到文件结尾；当用分号代替逗号时，会将第一个行地址当成当前行，因此`:/pattern/;+5d`就表示删除包含指定行模式的后续5行；全局命令`:g`可用于搜索并显示所有包含某个模式的行；而`g!`与`:v`则相反，搜索所有不包含某个模式的行，因此`:g/pattern/nu`就是寻找所有包含`pattern`的行并显示行号。


竖线`|`可以分隔命令，这样在同一个ex提示符下就能合并多个命令；但如果前面的命令影响了文件中的各行顺序，则后面的命令将在新的地址上运行，比如`:1,5 m 10 | g/pattern/nu`。

命令`:wq`写入文件同时离开编辑器，这是无条件写入，即便文件没有修改；而`:x`也是写入文件同时离开编辑器，但只有文件修改过时才会写入。它俩的差异在编辑源代码并使用make时很重要，make根据文件修改的次数而执行动作。

想强制执行命令时可以加`!`，比如`:q!`、`:w!`。可以用`:w newfile`将缓冲区内容以新的文件名保存；也可以保存文件的一部分内容，比如`:230,$w newfile`；而使用unix的重定向与附加运算符`>>`可将缓冲区内容追加到现有文件之后，比如`:.,500w >> somefile`；可以将一个文件的文本或数据复制到正在编辑的文件，`:r somefile`会将somefile的内容插入到编辑文件当前行的下面，若要插入其他位置，只需在`r`前指定行即可，因此`:r somefile`、`:$r somefile`、`:0r somefile`、`:/pattern/r somefile`分别在当前行、文件末尾、文件开头、下个pattern处插入somefile内容。

可以同时打开多个文件，例如`vim file1 file2`即可先编辑file1，然后使用`:n`即可调用下一文件；`:args`或简写为`:ar`可列出命令行上的文件列表，当前编辑文件名以方括号括起；`:rewind`或简写为`:rew`命令会将当前文件复位为命令行上第一个文件；无需在编辑时即调用多个文件，任何时候都可以用`:e somefile`切换到另一个文件，vim用`%`表示当前文件，用`#`表示调用`:e`之前编辑的文件，输入命令`:e #`即可在最近两个编辑的文件切换，而`%`则用于写出当前缓冲区到一个新文件，如`:w %.new`；在当前文件尚未存储时，不能使用`:e`或`:n`来切换文件，除非加`!`放弃这次编辑；还可以使用`<C-^>`来在最近编辑的两个文件之间切换。

使用命名缓冲区可以实现文本间内容的移动。具体有两种方法：

- 先在一个文件中拖拽或删除文本存入命名缓冲区，再用`:e`调用新文件，然后将缓冲区内容放置到新文件中，比如`f4yy | w | e newfile | fp`；
- 另一种方法是用ex的`ya`（拖动）与`pu`（放置）命令，它们分别与vim中的`y`与`p`运作方式相同，但是需与ex的寻址功能与命名缓冲区放在一起使用，比如`:160,224ya a | e newfile | pu a`。





##### 全局替换

替换命令的语法为`:s/old/new`，会将当前行中第一个出现的old改为new；而`:s/old/new/g`则会与将当前行所有old改为new，这里的`g`表示全局选项，会影响一行中的没一个模式；但不要与`:g`命令混淆，后者影响文件中那个的每一行。在`s`前加上地址可将有效范围超过一行，如`:1,$s/old/new/g`，等价于`%s/old/new/g`；选项`c`会在每一次替换前做确认，如`:1,30s/his/the/gc`，若确定替换，输入`y<enter>`，否则只输入`<enter>`。

在全局搜索模式再做替换的语法是：`:g/pattern/s/old/new/g`。第一个`g`表示此命令对所有行都起作用，`pattern`用于识别执行后面命令的行，之后就是前面的替换命令。而如果用于所有行的模式和用于替换的模式相同，则无需重复输入，因此命令`:g/editer/s//editor/g`与`:%s/eidter/editor/g`等价。`:g`命令还可以与其他诸如`:d`、`:mo`、`:co`命令结合起来，做一些全局的删除、移动与复制的工作。

正则表达式与vi的`/`、`?`搜索命令和ex的`:g`、`:s`都可以结合使用。

用在模式搜索中的元字符为：

|   字符   |                    作用                    |    备注    |
| :----: | :--------------------------------------: | :------: |
|  `.`   |              匹配除换行符外任何单一字符               |   包括空格   |
|  `*`   |       匹配位于此符号前一字符任意多次，可用在元字符后如`.*`       |   包括零次   |
|  `^`   |        在正则表达式开头时表示其后正则表达式必须位于一行开头        |          |
|  `$`   |        在正则表达式结尾时表示其前正则表达式必须位于一行结尾        |          |
|  `\`   |               其后的元字符为一般字符                |          |
|  `[]`  |   匹配其内任一字符；元字符大多失去特殊意义，`\-]`除外；^在开头表示否   | `[^0-9]` |
| `\(\)` | 将其间模式放到保留缓冲区1-9，用\1-\9取出，如`:%s/\(He\)or\(She\)/\2or\1` |          |
| `\<\>` |    匹配以`\<`后内容开头，或`\>`后内容结尾的单词，无需同时使用     |  `\<ac`  |
|  `~`   |    匹配上次**搜索**(`/`)使用的正则表达式，可在搜索和替换中使用    |          |

在POSIX标准中，方括号内的字符组称为方括号表达式，包括：

- 字符类，包括了用`[:`与`:]`括起的关键字，关键字描述了不同的字符类型，如下表

  |      类型      |       比较出字符       |
  | :----------: | :---------------: |
  | `[:alnum:]`  |      字母与数字字符      |
  | `[:alpha:]`  |       字母字符        |
  | `[:blank:]`  |      空格与制表符       |
  | `[:cntrl:]`  |       控制字符        |
  | `[:digit:]`  |       数字字符        |
  | `[:graph:]`  | 可打印的与可见的（不包括空格）字符 |
  | `[:lower:]`  |       小写字符        |
  | `[:print:]`  |   可打印的字符（包括空白）    |
  | `[:prunct:]` |       标点字符        |
  | `[:space:]`  |       空白字符        |
  | `[:upper:]`  |       大写字符        |
  | `[:xdigit:]` |      十六进制数字       |

- 校对符号，是由多字符组成但必须作为一个单位的序列，使用`[.`与`.]`括起所需字符；

- 等价类，列出所有应当被相称相等的字符集合，包含了区域设置中的已命名元素，用`[=`与`=]`括起。

这三种必须出现在方括号表达式的方括号中，如`[[:alpha:]!]`、`[[=e=]]`。

用于替换字串中的元字符有：

|         字符          |                    作用                    |
| :-----------------: | :--------------------------------------: |
|        `\n`         |      利用`\(\)`之间的第n个模式的文字做代换，n属于0～9       |
|         `\`         |              将后面的特殊字符当成一般字符              |
|         `&`         | 在替换字串中会被替换成搜索模式匹配出的完整文本，避免重新输入，如`%s/Yazs/&, Carl/`、`:%&g` |
|         `~`         |          找到字串中会被最后一个替换命令中的替换文本           |
|      `\u`/`\l`      | 使替换字符串中的下个字符变大写/小写，如`%s/\(It\) or\(he\)/\u\2 or \l\1` |
| `\U`/`\L`与`\e`/`\E` |      使替换字符串后接所有字符都大写或小写，直到`\e`或`\E`      |

所有的模式匹配都对大小写敏感。另外：

- 简单的`:s`与`:s//~/`一样，也即会重复上一次替换；
- `&`可以作为vi命令，
- 除`/`外，分隔符还可为任何非字母、非数字、非空格字符，但`\`、`"`、`|`除外，这在更改路径名称时很有用：`:%s;/user1/tim;/home/tim;g`；
- 启用`edcompatible`选项后vi会记住上一次替换的标志（`g`表全局、`c`表确认），并继续在下面的替换中；




##### 高级编辑方法

输入`:set all`可看到所有设置选项。

可通过`:!command`执行unix命令；如`:!date`，按下`<enter>`即可返回vim；通过`:sh`可创建shell执行那个命令，按`<C-D>`返回；`:read`可将Unix命令执行结果读入文件中，默认为当前行，也可在`:r`前指定行地址，如`:0r !date`会将日期信息读入文件开头，`:r !sort file`会将文件file内容排序后读入到当前行下面。

文本快也可作为Unix命令的标准输入，命令的输出替换缓冲区原来的文本块，可在ex或vi中通过命令来过滤文本；其中：

- ex使用行地址指示文本块，例如`:96,99!sort`会将96到99行内容送给sort过滤替换原有内容；
- vi使用文本对象（移动命令）指示，在任何代表文本块vi移动命令前加上感叹号，后面再加上要执行的unix命令，比如`!)command`会将下一个句子传送给command；但需要注意的是：
  - 感叹号不会立即出现在屏幕上；
  - 文本块必须超过一行，因此只能使用移动范围超过一行的按键（`G`、`{}`、`()`、`[[]]`、`+`、`-`）；要重复这种效果，可以在感叹号或文本对象前加上数值，如`!10+`与`10!+`都表示下10行；`w`命令这类对象需要重复的数量超过一行才能运行；也可以使用`/`加上模式与换行符来指定对象；
  - 此时影响的范围vim是当前所在行，而vi则是一整行；
  - 第二个感叹号这样的特殊文本对象只能用在这种命令语法中，表示当前这一行，比如`!!command`；而无论是整个序列还是文本对象，都可以在前面加上数值进行重操作，如`4!!sort`或`!4!sort`；
  - 重复前一个命令的语法是`!object!`。


vi可以定义缩写，让vi在插入模式将输入的缩写自动展开成原文，具体形式为`:ab abbr phrase`，只有在将缩写当成单词输入时才会展开，单词内的abbr不会被展开；要取消缩写执行`:unab abbr`；列出所有缩写`:ab`；缩写所用字符不能以单词形式出现在所代表的短语中，即不能产生递归定义。

`map`会将命令序列对应于一个没有用到的键，`map`与`ab`的区别在于是对vi的命令而非插入模式定义宏；映射命令`:map x sequence`；取消定义`:unmap x`；列出所有被映射字符`:map`；在定义映射命令时注意某些键不能单纯输入作为命令的一部分，如`<enter>`、`ESC`、`Backspace`、`<Delete>`，若希望作为命令一部分需在前面加上`<C-V>`转换按键的正常意义；在映射命令中，`<C-V>`表示`Ctrl`字符，换行是`C-M`，转义是`C-[`。在`map`命令后面加`!`可强制覆盖原来的意义，产生插入模式的映射行为。



##### 执行shell命令

```bash
:!command
```

不退出vim执行shell指令，结果显示在vim命令区域；特别可以`:!bash`启动一个shell并执行命令。

```bash
:r !command
```

将shell命令的结果插入下一行；比如`:r !date`读取系统时间并插入下一行。

```bash
:n1,n2 !command
```

将起始行号到结束行号内容输入到shell的command命令处理，并将处理结果替换起始行号到结束行号指定范围的内容：

- 如`:62,72 !sort`将62到72行的内容进行排序；
- 也可以只指定一行，如`:62 !tr [a-z] [A-Z]`将第62行；
- 可以用`.`表示当前行，如`:. !tr [a-z] [A-Z]`

```bash
:n1,n2 w !command
```

将起始行号到结束行号内容输入command命令处理，不改变当前文件内容。



##### 多文件

若vim未启动，

```bash
vim file1 file2		# 同一窗口打开两个文件
```

若已启动，

```bash
ctrl+6				# 下个文件
:open file			# 当前窗口打开文件
:e 
```

`ctrl+6` ：下个文件

`bn`：下个文件

`bp`：上个文件

多文档编辑的命令如下

:n          编辑下一个文档。 
:2n        编辑下两个文档。 
:N          编辑上一个文档。注意，该方法只能用于同时打开多个文档。 
:e 文档名        这是在进入vim后，不离开 vim 的情形下打开其他文档。 
:e# 或 Ctrl+ˆ      编辑上一个文档,用于两个文档相互交换编辑时使用。?# 代表的是编辑前一次编辑的文档 
:files 或 :buffers 或 :ls     可以列出目前 缓冲区 中的所有文档。加号 + 表示 缓冲区已经被修改过了。＃代表上一次编辑的文档，%是目前正在编辑中的文档 
:b 文档名或编号      移至该文档。 
:f  或 Ctrl+g     显示当前正在编辑的文档名称。 
:f 檔名         改变编辑中的文档名。(file)

通过vim打开多个文件（可以通过ctags或者cscope）

":ls"查看当前打开的buffer（文件）

":b num"切换文件（其中num为buffer list中的编号）



##### 多窗口

使用大写的O参数来垂直分屏：`vim -On file1 file2 ...`；

使用小写的o参数来水平分屏：`vim -on file1 file2 ...`

关闭当前窗口：`Ctrl+W c`；

关闭当前窗口，如果只剩最后一个了，则退出Vim：`Ctrl+W q`；

上下分割当前打开的文件：`Ctrl+W s`；

上下分割，并打开一个新的文件：`:sp filename`；

左右分割，并打开一个新的文件：`:vsp filename`；

把光标移到**右边**的屏：`Ctrl+W l`；

把光标移到**左边**的屏：`Ctrl+W h`；

把光标移到**上边**的屏：`Ctrl+W k`；

把光标移到**下边**的屏：`Ctrl+W j`；

把光标移到**下一个**屏：`Ctrl+W w`；

向右移动分屏：`Ctrl+W L`；

向左移动分屏：`Ctrl+W H`；

向上移动分屏：`Ctrl+W K`：

向下移动分屏：`Ctrl+W J`，

让所有的屏都有一样的高度：`Ctrl+W =`；

增加高度：`Ctrl+W +`；

减少高度：`Ctrl+W -`；

对于宽度可以使用`Ctrl+W <`或是`Ctrl+W >`，这可能需要最新的版本才支持。



##### 1.使用宏

**录制宏**：

- 在normal模式键入`q[a-z]`，即`q`加一个注册字母开始录制宏；
- 完成希望一次执行的操作；
- 回到normal模式键入`q`结束录制；

**使用宏**：

在normal模式下，键入`@[a-z]`执行宏，可配合数字使用。

键入`@@`是对上一次宏使用的重复使用。



##### 3.读取二进制文件

输入`vim -b datafile`；

在vim内执行`:%!xxd`。



##### 2.Python-mode插件

- `<leader>r`，运行python代码；
- `<leader>b`，添加/删除断点；
- 



##### 1.基础知识

在vim中有三种默认推出insert的命令：

- `<esc>`
- `<c-c>`
- `<c-[>`

在Vim中执行`:echo $MYVIMRC`命令可以快速得知vimrc文件的位置。

在编写复杂的Vimscript时，可能需要"打印一些信息"来调试程序。`:echo`命令会打印输出，但是一旦脚本运行完毕，那些输出信息就会消失。使用`:echom`打印的信息会保存下来，可以执行`:messages`命令再次查看。

vimscript中通过"字符添加注释。要养成习惯添加注释说明某段代码是干什么的，如果有一个相关的帮助主题（help topic），最好在注释中说明。

Vim拥有很多选项可以设置以改变其展现方式，主要有两种选项：布尔选项（值为"on"或"off"）和键值选项。

**布尔选项**：

- 布尔选项的通用配置方法`:set <name>`打开选项、`:set no<name>`关闭选项；
- 添加一个!（感叹号）至布尔选项后面会切换对于选项的值，比如`set number!`；
- 以使用一个?符号获取一个选项的当前值，如`set number?`。

**键值选项：**

- 通过`:set <name>=<value>`命令设置非布尔选项的选项值，并使用`:set <name>?`命令查看选项的当前值；
- 也可以一次设置多个选项，如`:set number numberwidth=6`。

使用`setlocal option`可以设定基于缓冲区的选项。但并非所有选项都可以使用setlocal设置，若希望获知某选项是否能设为本地选项，执行`:help`查看其帮助文档。

对于大多数命令和选项，Vim支持使用它们的缩写。但强烈提醒不要在~/.vimrc或者编写的插件中使用这些缩写。

**状态条：**

Vim允许自定义每个窗口底部状态条显示的文字，可以通过设置`statusline`选项来进行自定义，执行`:set statusline=%f`可以在状态条上看到当前所编辑文件的路径（相对于当前路径）。执行

```vimscript
:set statusline=%f\ -\ FileType:\ %y
```

可以在状态条中看到类似`foo.markdown - FileType: [markdown]`这样的文字。注意状态条中的空格需要反斜线进行转义，这是因为set可以同时设置多个选项，这些选项会用空格分隔。状态条设置可以很快变得非常复杂，不过有一个更好的办法来设置它们以至于让它们看起来更清晰。执行

```vimscript
:set statusline=%f         " 文件的路径
:set statusline+=\ -\      " 分隔符
:set statusline+=FileType: " 标签
:set statusline+=%y        " 文件的类型
:set statusline+=%l        " 当前行号
:set statusline+=/         " 分隔符
:set statusline+=%L        " 总行数
```

先使用`=`来设置状态条显示文件名，将之前的所有会在状态条中显示的值都屏蔽掉；之后再使用`+=`逐渐添加其他要显示的内容。可以在%后面添加额外的字符来改变状态条中信息的显示样式：`:set statusline=[%4l]`，这样文件行数会至少显示为4个字符的宽度；默认情况下在值的左边添加边距，可以使用-将边距添加在右边。对于会被显示为数字的代码，你可以让Vim使用0代替空格来填充边距：`:set statusline=%04l`；最后还可以设置一个代码所要输出的值的最大宽度，执行`:set statusline=%F`，`%F`会显示当前文件的完整路径；执行`:set statusline=%.20F`改变最大宽度，必要时路径会被删简。

状态条中代码的**通用格式是`%-0{minwid}.{maxwid}{item}`**，除了%和item外其他都是可选的。

##### 2.映射

可以使用`<keyname>`告诉Vim一个特殊的按键，比如`map <space> viw`，`map <c-d>`，这是ctrl键修饰键，还有alt修饰键等。需注意键盘映射无法使用注释，命令`:map <space> viw " Select word`不会像希望地那样工作。

可以使用nmap、vmap和imap命令分别指定映射仅在normal、visual、insert模式有效。比如想在insert模式下通过按键`Ctrl+d`删除整行，可以是`imap <c-d> <esc>ddi`。

\*map系列命令存在递归的危险，在安装插件时也有冲突的危险。每一个\*map系列的命令都有个对应的\*noremap命令，包括：noremap/nnoremap、vnoremap和inoremap。这些命令将不递归解释映射的内容，在任何时候都应使用\*noremap映射。

有些按键并不经常使用，比如在normal模式下几乎不会用到-、H、L、<space>、<cr>和<bs>这些按键的功能，依据工作方式还有其他不会用到的按键，这些按键都可以随意映射。且vim可以映射多个按键，这意味着可以用一个不常用按键（如`-`）作为“前缀”，后接其它字符作为一个整体进行映射。称这个“前缀”为“leader”，可以按个人喜好设置leader键，比如：`let mapleader = "-"`。

Vim还有另一个“local leader“，用于那些只对某类文件（如Python、HTML文件）而设置的映射，比如`:let maplocalleader = "\\"`，注意使用`\\`而不是`\`，`\`在Vimscript中是转义字符。

映射`:nnoremap <leader>ev :vsplit $MYVIMRC<cr>`，称其为“编辑vimrc命令”；但`~/.vimrc`文件只在启动Vim的时候才会读取，添加`:nnoremap <leader>sv :source $MYVIMRC<cr>`，称之为“重读vimrc命令”。

通过映射实现用双引号、单引号将单词包围：

```vimscript
:nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
:nnoremap <leader>' viw<esc>a'<esc>hbi'<esc>lel
:nnoremap <leader>" bviw<esc>a"<esc>hbi"<esc>lel
```

在定义新映射后，改掉原习惯的最好方式是将其映射为`<nop>`，比如：`:inoremap <esc> <nop>`。

命令`:nnoremap <buffer> <leader>x dd`为缓冲区映射，只在定义它的缓冲区（即在定义此映射时正在编辑的文件）有效。但更常使用只用于特定缓冲区的`<localleader>`。`<leader>`和`<localleader>`的使用就像设置一种命名空间，使得所有不同的映射更加清晰直接。在编写插件时候尤为重要，它会防止插件覆盖别人用<leader>设置的全局映射。另外，本地映射会遮盖同名的全局映射。

##### 3.缩写

Vim有个称为"abbreviations"的特性，与映射有点类似，但是它用于insert、replace和command模式，灵活且强大。比如运行命令`:iabbrev adn and`，诸如这样的输入纠错是abbreviations的一个很实用的用法。

紧跟一个abbreviation输入"non-keyword character"后Vim会替换那个abbreviation。 "non-keyword character"指那些不在iskeyword选项中的字符。运行命令：`:set iskeyword?`将看到类似于`iskeyword=@,48-57,_,192-255`的结果。这个格式很复杂，但本质上 "keyword characters"包含一下几种：

- 下划线字符(_)；
- 所有字母字符，包括大小写；
- ASCII值在48到57之间的字符（数字0-9）；
- ASCII值在192到255之间的字符（一些特殊ASCII字符）。

若希望阅读这个选项格式的描述可以运行命令`:help isfname`。现在只要记住输入**非字母、数字、下划线**的字符就会引发abbreviations替换。

除纠错笔误，abbreviations还有很多用途。 运行命令：

```vimscript
:iabbrev @@    steve@stevelosh.com
:iabbrev ccopy Copyright 2013 Steve Losh, all rights reserved.
```

会将常用的一长串字符压缩至几个字符，可以省去很多的麻烦。

abbreviations和mappings很像，但是他们的定位不同。mappings不管被映射字符串的前后字符是什么--只在文本中查找指定的字符串并替换它们，而abbreviation会注意缩写字符串的前后字符，只会在需要的时候替换它。

定义本地缓冲区的缩写：

```vimscript
:iabbrev <buffer> --- &mdash;
```

##### 4.自动命令

自动命令可以让Vim自动执行某些指定的命令，这些指定的命令会在某些事件发生的时候执行。下面命令使得vim在开始编辑文件时就创建它们：

```vimscript
:autocmd BufNewFile * :write
         ^          ^ ^
         |          | |
         |          | 要执行的命令
         |          |
         |          用于事件过滤的“模式（pattern）”
         |
         要监听的“事件”
```

自动命令的第一部分是想监听的事件的类型。Vim提供了很多可以监听的事件，包括：

- 开始编辑一个当前并不存在的文件；
- 读取一个文件，不管这个文件是否存在；
- 改变一个缓冲区的filetype设置；
- 在某段时间内不按下键盘上面的某个按键；
- 进入或退出插入模式；

可用`:help autocmd-events`查看自动命令可以绑定的所有事件，可以利用它们做很多事情。自动命令的下一部分是“模式”，限定你要执行命令的范围：

```vimscript
:autocmd BufNewFile *.txt :write
```

自动命令的最后一部分是事件发生时要执行的命令，跟执行其他命令一样，但不能使用特殊的字符，例如<cr>，不过也能突破这个限制。下面的命令会在文件保存前重新进行文本缩进处理。

```vimscript
:autocmd BufWritePre *.html :normal gg=G
```

可以创建一个绑定多个事件的自动命令，这些事件使用逗号分隔开。比如下面的命令不仅在写html文件时进行缩进处理，读的时候也会进行缩进处理：

```vimscript
:autocmd BufWritePre,BufRead *.html :normal gg=G
```

在vim脚本编程应该同时使用BufRead和BufNewFile这两个事件来运行命令，这样在打开某个类型的文件，不论这个文件是否存在命令都会执行：

```vimscript
:autocmd BufNewFile,BufRead *.html setlocal nowrap
```

最有用的事件是FileType，它会在vim设置一个缓冲区的filetype时触发，这样就可以对不同类型文件设置不同的映射。下面的命令对不同的文件用`<localleader>I`来对当前行进行注释：

```vimscript
:autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
:autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>
```

下面使用本地缓冲区的缩写和自动命令来创建一个简单的“snippet”系统，依据文件类型相应地展开if语句：

```vimscript
:autocmd FileType python     :iabbrev <buffer> iff if:<left>
:autocmd FileType javascript :iabbrev <buffer> iff if ()<left>
```

最好的学习使用这些snippets的方法是禁用之前做这些事情的方式，执行`:iabbrev <buffer> return NOPENOPENOPE`会强迫使用缩写，这个命令在输入return的时候不会输出任何东西。

重复定义自动命令并不会代替原来的自动命令，而是将两个都执行。当加载`~/.vimrc`文件时，vim会重新读取整个文件，包括所定义的任何自动命令！这就意味着每次加载`~/.vimrc`文件时，vim都会复制之前的自动命令，这会降低Vim的运行速度，因为它会一次又一次地执行相同的命令。

解决这个问题的第一步是将相关的自动命令收集起来放到一个已命名的组（groups）中。新开一个vim实例，可以清除之前所创建的自动命令；但多次使用augroup时，vim每次都会组合那些组。要清除一个组，需把autocmd!这个命令包含在组里面。执行下面的命令：

```vimscript
augroup filetype_html
    autocmd!
    autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
augroup END

```

使用这种方式将自动命令添加到`~/.vimrc`中，这样每次加载它的时候就不会复制自动命令了。不过这会导致`~/.vimrc`中代码快速增长以至失去控制，并且变得难于阅读浏览。对此可以使用vim的代码折叠功能，将多行代码组织起来的作为一个部分然后对这部分的代码进行折叠。首先我们需要为vim脚本文件设置折叠，并使用折叠标记让它也能被折叠。在~/.vimrc文件中添加下面几行：

```vimscript
" Vimscript file settings ---------------------- {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}
```

这会告诉Vim对任何Vim脚本文件使用marker折叠方法。这样切换到常用模式，将光标放到这些文字中的任意一行，然后敲击`za`。Vim会折叠从包含{{{的行到包含}}}的行之间的所有行。再敲击`za`会展开所有这些行。

##### Operator-Pending映射

一个operator（操作）就是一个命令，在这个命令的后面输入一个movement（移动）命令，Vim就开始对文本从当前所在的位置开始执行前面的操作命令，一直到移动命令带到的位置结束。下面的映射会处理括号内所有内容；：

```vimscript
:onoremap p i(
```

下面的映射则会对当前位置到return上面的内容执行operator：

```vimscript
:onoremap b /return<cr>
```

当需要搞清楚如恶化定义一个新operator-pending movement时，可以从下面几个步骤来思考：

1. 在光标所在的位置开始；
2. 进入可视模式(charwise)；
3. ... 把映射的按键放到这里 ...；
4. 所有想包含在movement中的文字都被选中。

所要做的工作就是在第三步中填上合适的按键。也可以改变开始处理的位置，下面的映射在一行的任意位置执行时，分别处理当前位置后／前括号的内容（`:normal!`可以在常用模式下模拟按下按键）：

```vimscript
:onoremap in( :<c-u>normal! f(vi(<cr>
:onoremap il( :<c-u>normal! F)vi(<cr>

```

<c-u>用于删除vim可能插入的range。下面两条规则可以很直观的以多种方式创建operator-pending映射：

- 如果operator-pending映射以在可视模式下选中文本结束，vim会操作这些文本；
- 否则，vim会操作从光标的原始位置到一个新位置之间的文本。

下面看一些operator-pending映射的例子。用=作为“下划线”的行会被Markdown当作标题，现在创建可以让通过movements定位到标题的映射：

```vimscript
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>

```



`echo`命令会打印输出，但脚本运行完毕后输出信息便会消失；而使用`:echom`打印的信息会保存下来，可以执行`:messages`命令再次查看。

Vim拥有很多选项可以设置以改变其展现方式。主要有两种选项：

- 布尔选项（值为"on"或"off"）和键值选项。所有的布尔选项都是这种配置方法。`:set <name>`打开选项、`:set no<name>`关闭选项、`:set <name>!`切换布尔选项、`set <name>?`查看选项值。
- 有些选项并不只有off或on两种状态，它们需要一个值，可以通过`:set <name>=<value>`命令改变 非布尔选项的选项值，并使用`:set <name>?`命令查看选项的当前值。可以在一个`:set`命令中设置多个布尔和键值选项的值。

可以使用`<keyname>`告诉Vim一个特殊的按键。

可以使用`nmap`、`vmap`和`imap`命令分别指定映射仅在normal、visual、insert模式有效。

`*map`系列命令的一个缺点就是存在递归的危险。另外一个是如果你安装一个插件，插件 映射了同一个按键为不同的行为，两者冲突，有一个映射就无效了。

当安装一个新的插件时，可能你不会使用或记住每一个其创建的映射。即使你记住了，你还得 回看下你的`~/.vimrc`文件以确保你自定义的映射与插件创建的没有冲突。

每一个`*map`系列的命令都有个对应的`*noremap`命令，包括：`noremap`/`nnoremap`、 `vnoremap`和`inoremap`。这些命令将不递归解释映射的内容。

Vim有另外一个“leader”成为“local leader“。这个leader用于那些只对某类文件 （如Python文件、HTML文件）而设置的映射。

`$MYVIMRC`是指定你的`~/.vimrc`文件的特殊Vim变量。

Vim有个称为"abbreviations"的特性，与映射有点类似，但是它用于insert、replace和 command模式。这个特性灵活且强大。输入纠错是abbreviations的一个很实用的用法。紧跟一个abbreviation输入"non-keyword character"后Vim会替换那个abbreviation。 "non-keyword character"指那些不在`iskeyword`选项中的字符。可以通过`:set iskeyword?`查看，但本质上 "keyword characters"包含一下几种：

- 下划线字符 (`_`).
- 所有字母字符，包括大小写。
- ASCII值在48到57之间的字符（数字0-9）。
- ASCII值在192到255之间的字符（一些特殊ASCII字符）。

只要记住输入非字母、数字、下划线的字符就会引发abbreviations替换。

abbreviations和mappings很像，但是他们的定位不同。mappings不管被映射字符串的前后字符是什么-- 它只在文本中查找指定的字符串并替换他们。

在Vim中有很多默认的方式可以退出插入模式：

- `<esc>`
- `<c-c>`
- `<c-[>`

重新学习一个mapping的窍门就是*强制*将之前的按键设置为不可用，*强迫*自己使用新的mapping。执行下面的命令：

```
:inoremap <esc> <nop>
```

这个命令会告诉Vim在插入模式下敲击escape按键后执行`<nop>`(no operation)，这样escape按键在插入模式下就无效了。ok，现在你就*不得不*使用`jk`这个mapping来退出插入模式了。